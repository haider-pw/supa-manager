name: Deploy to Production

# Trigger deployment on push to main branch
on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual trigger from GitHub UI

jobs:
  deploy:
    name: Deploy to Production Server
    runs-on: ubuntu-latest
    environment: production  # Use GitHub Environment for better organization
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deploy to Production Server
        uses: appleboy/ssh-action@v1.0.3
        env:
          # SECRETS (sensitive data - encrypted)
          DATABASE_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          ENCRYPTION_SECRET: ${{ secrets.ENCRYPTION_SECRET }}
          
          # VARIABLES (configuration - plain text)
          DOMAIN_BASE: ${{ vars.DOMAIN_BASE }}
          DOMAIN_STUDIO_URL: ${{ vars.DOMAIN_STUDIO_URL }}
          SERVICE_VERSION_URL: ${{ vars.SERVICE_VERSION_URL }}
          POSTGRES_DISK_SIZE: ${{ vars.POSTGRES_DISK_SIZE }}
          POSTGRES_DEFAULT_VERSION: ${{ vars.POSTGRES_DEFAULT_VERSION }}
          POSTGRES_DOCKER_IMAGE: ${{ vars.POSTGRES_DOCKER_IMAGE }}
          PROVISIONING_ENABLED: ${{ vars.PROVISIONING_ENABLED }}
          PROVISIONING_DOCKER_HOST: ${{ vars.PROVISIONING_DOCKER_HOST }}
          PROVISIONING_PROJECTS_DIR: ${{ vars.PROVISIONING_PROJECTS_DIR }}
          PROVISIONING_BASE_POSTGRES_PORT: ${{ vars.PROVISIONING_BASE_POSTGRES_PORT }}
          PROVISIONING_BASE_KONG_HTTP_PORT: ${{ vars.PROVISIONING_BASE_KONG_HTTP_PORT }}
          NEXT_PUBLIC_SITE_URL: ${{ vars.NEXT_PUBLIC_SITE_URL }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ vars.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ vars.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
          NEXT_PUBLIC_GOTRUE_URL: ${{ vars.NEXT_PUBLIC_GOTRUE_URL }}
          NEXT_PUBLIC_API_URL: ${{ vars.NEXT_PUBLIC_API_URL }}
          NEXT_PUBLIC_API_ADMIN_URL: ${{ vars.NEXT_PUBLIC_API_ADMIN_URL }}
          PLATFORM_PG_META_URL: ${{ vars.PLATFORM_PG_META_URL }}
          NEXT_PUBLIC_HCAPTCHA_SITE_KEY: ${{ vars.NEXT_PUBLIC_HCAPTCHA_SITE_KEY }}
          ALLOW_SIGNUP: ${{ vars.ALLOW_SIGNUP }}
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USER }}
          password: ${{ secrets.PRODUCTION_PASSWORD }}
          port: 22
          script_stop: true
          envs: >-
            DATABASE_PASSWORD,JWT_SECRET,ENCRYPTION_SECRET,
            DOMAIN_BASE,DOMAIN_STUDIO_URL,SERVICE_VERSION_URL,
            POSTGRES_DISK_SIZE,POSTGRES_DEFAULT_VERSION,POSTGRES_DOCKER_IMAGE,
            PROVISIONING_ENABLED,PROVISIONING_DOCKER_HOST,PROVISIONING_PROJECTS_DIR,
            PROVISIONING_BASE_POSTGRES_PORT,PROVISIONING_BASE_KONG_HTTP_PORT,
            NEXT_PUBLIC_SITE_URL,NEXT_PUBLIC_SUPABASE_URL,NEXT_PUBLIC_SUPABASE_ANON_KEY,
            NEXT_PUBLIC_GOTRUE_URL,NEXT_PUBLIC_API_URL,NEXT_PUBLIC_API_ADMIN_URL,
            PLATFORM_PG_META_URL,NEXT_PUBLIC_HCAPTCHA_SITE_KEY,ALLOW_SIGNUP
          script: |
            echo "=== Starting Deployment ==="
            echo "Timestamp: $(date)"
            
            # Navigate to installation directory
            cd /opt/supamanage || exit 1
            
            # Backup current state
            echo "Creating backup of current deployment..."
            BACKUP_DIR="/opt/supamanage-backups/$(date +%Y%m%d-%H%M%S)"
            mkdir -p "$BACKUP_DIR"
            cp docker-compose.prod.yml "$BACKUP_DIR/" || true
            cp .env "$BACKUP_DIR/" || true
            cp supa-manager/.env "$BACKUP_DIR/supa-manager.env" || true
            cp studio/.env "$BACKUP_DIR/studio.env" || true
            
            # Update environment files with secrets from GitHub
            echo "Updating environment configuration..."
            
            # URL-encode the database password for DATABASE_URL
            DB_PASSWORD_ENCODED=$(echo -n "$DATABASE_PASSWORD" | jq -sRr @uri)
            
            # Update root .env file (for docker-compose)
            cat > .env << 'ENVEOF'
DATABASE_PASSWORD=$DATABASE_PASSWORD
ENVEOF
            
            # Update supa-manager .env file
            cat > supa-manager/.env << 'APIEOF'
DATABASE_URL=postgres://postgres:${DB_PASSWORD_ENCODED}@database:5432/supabase
ALLOW_SIGNUP=$ALLOW_SIGNUP
JWT_SECRET=$JWT_SECRET
ENCRYPTION_SECRET=$ENCRYPTION_SECRET
SERVICE_VERSION_URL=$SERVICE_VERSION_URL
POSTGRES_DISK_SIZE=$POSTGRES_DISK_SIZE
POSTGRES_DEFAULT_VERSION=$POSTGRES_DEFAULT_VERSION
POSTGRES_DOCKER_IMAGE=$POSTGRES_DOCKER_IMAGE
DOMAIN_STUDIO_URL=$DOMAIN_STUDIO_URL
DOMAIN_BASE=$DOMAIN_BASE
PROVISIONING_ENABLED=$PROVISIONING_ENABLED
PROVISIONING_DOCKER_HOST=$PROVISIONING_DOCKER_HOST
PROVISIONING_PROJECTS_DIR=$PROVISIONING_PROJECTS_DIR
PROVISIONING_BASE_POSTGRES_PORT=$PROVISIONING_BASE_POSTGRES_PORT
PROVISIONING_BASE_KONG_HTTP_PORT=$PROVISIONING_BASE_KONG_HTTP_PORT
APIEOF
            
            # Update studio .env file
            cat > studio/.env << 'STUDIOEOF'
PLATFORM_PG_META_URL=$PLATFORM_PG_META_URL
NEXT_PUBLIC_SITE_URL=$NEXT_PUBLIC_SITE_URL
NEXT_PUBLIC_SUPABASE_URL=$NEXT_PUBLIC_SUPABASE_URL
NEXT_PUBLIC_SUPABASE_ANON_KEY=$NEXT_PUBLIC_SUPABASE_ANON_KEY
NEXT_PUBLIC_GOTRUE_URL=$NEXT_PUBLIC_GOTRUE_URL
NEXT_PUBLIC_API_URL=$NEXT_PUBLIC_API_URL
NEXT_PUBLIC_API_ADMIN_URL=$NEXT_PUBLIC_API_ADMIN_URL
NEXT_PUBLIC_HCAPTCHA_SITE_KEY=$NEXT_PUBLIC_HCAPTCHA_SITE_KEY
STUDIOEOF
            
            # Set proper permissions
            chmod 600 .env supa-manager/.env studio/.env
            
            echo "Environment files updated successfully"
            
            # Pull latest code
            echo "Pulling latest code from GitHub..."
            git fetch origin
            CURRENT_COMMIT=$(git rev-parse HEAD)
            git pull origin main
            NEW_COMMIT=$(git rev-parse HEAD)
            
            if [ "$CURRENT_COMMIT" = "$NEW_COMMIT" ]; then
              echo "No new code changes detected."
              echo "Environment files have been updated - restarting services..."
              docker compose -f docker-compose.prod.yml up -d
              sleep 10
            else
              echo "Updating from commit $CURRENT_COMMIT to $NEW_COMMIT"
              
              # Check if supa-manager code changed
              SUPA_MANAGER_CHANGED=$(git diff --name-only $CURRENT_COMMIT $NEW_COMMIT | grep "^supa-manager/" || true)
              
              # Check if studio changed
              STUDIO_CHANGED=$(git diff --name-only $CURRENT_COMMIT $NEW_COMMIT | grep "^studio/" || true)
              
              # Rebuild and restart services
              if [ -n "$SUPA_MANAGER_CHANGED" ]; then
                echo "Supa-manager code changed, rebuilding API..."
                docker compose -f docker-compose.prod.yml build supa-manager
                docker compose -f docker-compose.prod.yml up -d supa-manager
                echo "API service restarted"
              else
                echo "No changes in supa-manager, skipping API rebuild"
              fi
              
              if [ -n "$STUDIO_CHANGED" ]; then
                echo "Studio code changed, rebuilding Studio..."
                cd studio
                ./build.sh v1.24.04 supa-manager/studio:production .env
                cd ..
                docker compose -f docker-compose.prod.yml up -d studio
                echo "Studio service restarted"
              else
                echo "No changes in studio, skipping Studio rebuild"
              fi
              
              # If docker-compose.prod.yml changed, restart all services
              COMPOSE_CHANGED=$(git diff --name-only $CURRENT_COMMIT $NEW_COMMIT | grep "^docker-compose.prod.yml" || true)
              if [ -n "$COMPOSE_CHANGED" ]; then
                echo "Docker compose configuration changed, restarting all services..."
                docker compose -f docker-compose.prod.yml up -d
              fi
            fi
            
            # Show running containers
            echo ""
            echo "=== Deployment Complete ==="
            echo "Running containers:"
            docker compose -f docker-compose.prod.yml ps
            
            # Check health
            echo ""
            echo "Checking service health..."
            sleep 5
            
            # Check API health
            API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8081/ || echo "000")
            if [ "$API_STATUS" = "200" ] || [ "$API_STATUS" = "404" ]; then
              echo "✓ API is responding (HTTP $API_STATUS)"
            else
              echo "✗ API health check failed (HTTP $API_STATUS)"
              exit 1
            fi
            
            # Check Studio health
            STUDIO_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3001/ || echo "000")
            if [ "$STUDIO_STATUS" = "200" ] || [ "$STUDIO_STATUS" = "307" ]; then
              echo "✓ Studio is responding (HTTP $STUDIO_STATUS)"
            else
              echo "✗ Studio health check failed (HTTP $STUDIO_STATUS)"
              exit 1
            fi
            
            echo ""
            echo "=== Deployment Successful ==="
            echo "Deployed commit: $NEW_COMMIT"
            echo "Production URL: https://www.supamanage.buzz"
            echo "Studio URL: https://studio.supamanage.buzz"
      
      - name: Notify on Success
        if: success()
        run: |
          echo "✓ Deployment completed successfully"
          echo "Production is now running the latest code from main branch"
      
      - name: Notify on Failure
        if: failure()
        run: |
          echo "✗ Deployment failed"
          echo "Please check the logs and fix any issues"
          exit 1
